# Political War - Development Guide for Claude Code

## Project Overview

This guide provides step-by-step instructions for building **Political War**, a turn-based strategy web game inspired by Nuclear War. This document is optimized for Claude Code to follow.

---

## Technology Stack

### Frontend
- **React 18+** with hooks
- **TypeScript** for type safety
- **Vite** as build tool (fast, modern)
- **TailwindCSS** for styling
- **Framer Motion** for animations
- **Canvas API** or **SVG** for game board visualization

### Backend
- **Node.js 18+**
- **Express.js** for API routes
- **TypeScript** for type safety
- **Socket.io** for real-time multiplayer
- **PostgreSQL** with **Prisma ORM** for database
- **JWT** for authentication (optional for v1)

### DevOps
- **Vercel** for frontend deployment
- **Railway** or **Render** for backend deployment
- **GitHub** for version control
- **ESLint + Prettier** for code quality

---

## Project Structure

```
political-war/
├── client/                    # Frontend React app
│   ├── public/
│   │   └── assets/
│   │       ├── images/        # Faction icons, buildings
│   │       └── sounds/        # Sound effects (optional)
│   ├── src/
│   │   ├── components/
│   │   │   ├── game/
│   │   │   │   ├── GameBoard.tsx
│   │   │   │   ├── FactionCard.tsx
│   │   │   │   ├── BuildingDisplay.tsx
│   │   │   │   ├── CardHand.tsx
│   │   │   │   ├── CardQueue.tsx
│   │   │   │   ├── EventLog.tsx
│   │   │   │   └── ActionPanel.tsx
│   │   │   ├── ui/
│   │   │   │   ├── Button.tsx
│   │   │   │   ├── Modal.tsx
│   │   │   │   └── Card.tsx
│   │   │   └── layout/
│   │   │       ├── Header.tsx
│   │   │       └── Footer.tsx
│   │   ├── pages/
│   │   │   ├── Home.tsx
│   │   │   ├── Game.tsx
│   │   │   ├── Leaderboard.tsx
│   │   │   └── HowToPlay.tsx
│   │   ├── hooks/
│   │   │   ├── useGame.ts
│   │   │   ├── useSocket.ts
│   │   │   └── useAI.ts
│   │   ├── types/
│   │   │   ├── game.types.ts
│   │   │   ├── card.types.ts
│   │   │   └── faction.types.ts
│   │   ├── utils/
│   │   │   ├── gameLogic.ts
│   │   │   ├── cardEffects.ts
│   │   │   ├── aiEngine.ts
│   │   │   └── validators.ts
│   │   ├── constants/
│   │   │   ├── factions.ts
│   │   │   ├── cards.ts
│   │   │   └── events.ts
│   │   ├── App.tsx
│   │   ├── main.tsx
│   │   └── index.css
│   ├── package.json
│   ├── tsconfig.json
│   ├── vite.config.ts
│   └── tailwind.config.js
│
├── server/                    # Backend Node.js app
│   ├── src/
│   │   ├── controllers/
│   │   │   ├── gameController.ts
│   │   │   ├── userController.ts
│   │   │   └── leaderboardController.ts
│   │   ├── services/
│   │   │   ├── gameService.ts
│   │   │   ├── aiService.ts
│   │   │   └── socketService.ts
│   │   ├── models/
│   │   │   ├── Game.ts
│   │   │   ├── User.ts
│   │   │   └── Match.ts
│   │   ├── routes/
│   │   │   ├── gameRoutes.ts
│   │   │   ├── userRoutes.ts
│   │   │   └── leaderboardRoutes.ts
│   │   ├── middleware/
│   │   │   ├── auth.ts
│   │   │   └── errorHandler.ts
│   │   ├── utils/
│   │   │   ├── gameEngine.ts
│   │   │   ├── cardDeck.ts
│   │   │   └── validators.ts
│   │   ├── config/
│   │   │   ├── database.ts
│   │   │   └── socket.ts
│   │   └── server.ts
│   ├── prisma/
│   │   ├── schema.prisma
│   │   └── migrations/
│   ├── package.json
│   └── tsconfig.json
│
├── shared/                    # Shared types between client/server
│   ├── types/
│   │   ├── game.ts
│   │   ├── cards.ts
│   │   └── factions.ts
│   └── constants/
│       ├── gameConfig.ts
│       └── cardDefinitions.ts
│
├── .gitignore
├── README.md
└── package.json               # Root package.json for workspace
```

---

## Phase 1: Project Setup (Day 1)

### Step 1: Initialize Project

```bash
# Create root directory
mkdir political-war
cd political-war

# Initialize as npm workspace
npm init -y

# Create client (React + Vite + TypeScript)
npm create vite@latest client -- --template react-ts

# Create server directory
mkdir server
cd server
npm init -y
cd ..

# Create shared directory
mkdir -p shared/types shared/constants

# Initialize git
git init
echo "node_modules" > .gitignore
echo ".env" >> .gitignore
echo "dist" >> .gitignore
echo "build" >> .gitignore
```

### Step 2: Configure Workspace

Edit root `package.json`:
```json
{
  "name": "political-war",
  "private": true,
  "workspaces": [
    "client",
    "server",
    "shared"
  ],
  "scripts": {
    "dev": "concurrently \"npm run dev:client\" \"npm run dev:server\"",
    "dev:client": "npm run dev --workspace=client",
    "dev:server": "npm run dev --workspace=server",
    "build": "npm run build --workspace=client && npm run build --workspace=server"
  }
}
```

### Step 3: Install Dependencies

**Client:**
```bash
cd client
npm install socket.io-client framer-motion react-router-dom
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
cd ..
```

**Server:**
```bash
cd server
npm install express socket.io cors dotenv
npm install @prisma/client
npm install -D typescript @types/node @types/express @types/cors ts-node-dev prisma
npx tsc --init
npx prisma init
cd ..
```

**Root:**
```bash
npm install -D concurrently
```

---

## Phase 2: Core Type Definitions (Day 1)

### Create: `shared/types/game.ts`

```typescript
export enum GamePhase {
  SETUP = 'SETUP',
  PEACETIME = 'PEACETIME',
  CONFLICT = 'CONFLICT',
  FINAL_RETALIATION = 'FINAL_RETALIATION',
  ENDED = 'ENDED'
}

export enum FactionType {
  MAFA = 'MAFA',
  BLAM = 'BLAM',
  AUNTY_FAFA = 'AUNTY_FAFA',
  PROUD_GALS = 'PROUD_GALS',
  LMNOP = 'LMNOP'
}

export interface PopulationCard {
  id: string;
  value: number; // 1, 5, 10, 15, or 25 million
}

export interface Faction {
  id: string;
  type: FactionType;
  name: string;
  isAI: boolean;
  population: PopulationCard[];
  totalPopulation: number;
  buildingHP: number;
  maxBuildingHP: number;
  hand: GameCard[];
  queue: GameCard[]; // 3 face-down cards
  organizations: OrganizationCard[];
  specialAbilityUsed: boolean;
  isEliminated: boolean;
  capturedBuildings: string[]; // IDs of captured buildings
}

export interface GameState {
  id: string;
  phase: GamePhase;
  round: number;
  currentPlayerIndex: number;
  factions: Faction[];
  deck: GameCard[];
  discardPile: GameCard[];
  eventLog: GameEvent[];
  winner: string | null;
}

export interface GameEvent {
  id: string;
  timestamp: number;
  type: string;
  message: string;
  factionId?: string;
}
```

### Create: `shared/types/cards.ts`

```typescript
export enum CardType {
  COVERT_OP = 'COVERT_OP',
  PROPAGANDA = 'PROPAGANDA',
  ORGANIZATION = 'ORGANIZATION',
  ACTION_PLAN = 'ACTION_PLAN',
  DEFENSE = 'DEFENSE'
}

export enum ActionType {
  PROTEST = 'PROTEST',
  PRAYER = 'PRAYER',
  THROWING = 'THROWING',
  INVASION = 'INVASION'
}

export interface GameCard {
  id: string;
  type: CardType;
  name: string;
  description: string;
  imageUrl?: string;
}

export interface CovertOpCard extends GameCard {
  type: CardType.COVERT_OP;
  effect: CovertOpEffect;
}

export interface PropagandaCard extends GameCard {
  type: CardType.PROPAGANDA;
  stealAmount: number;
  backfireChance?: number;
  targetAll?: boolean;
}

export interface OrganizationCard extends GameCard {
  type: CardType.ORGANIZATION;
  actionType: ActionType;
  attachedAction?: ActionPlanCard;
}

export interface ActionPlanCard extends GameCard {
  type: CardType.ACTION_PLAN;
  actionType: ActionType;
  damage?: number;
  targetType: 'POPULATION' | 'BUILDING' | 'BOTH';
  specialEffect?: string;
}

export interface DefenseCard extends GameCard {
  type: CardType.DEFENSE;
  blocksType: ActionType | CardType;
  damageReduction?: number;
}

export type CovertOpEffect = 
  | { type: 'DAMAGE_POPULATION'; amount: number; targetId: string }
  | { type: 'DAMAGE_BUILDING'; amount: number; targetId: string }
  | { type: 'STEAL_POPULATION'; amount: number; targetId: string }
  | { type: 'SKIP_TURN'; targetId: string }
  | { type: 'REDIRECT_ATTACK'; fromId: string; toId: string }
  | { type: 'CANCEL_PROPAGANDA' }
  | { type: 'GAIN_POPULATION'; amount: number };
```

### Create: `shared/types/factions.ts`

```typescript
import { FactionType } from './game';

export interface FactionConfig {
  type: FactionType;
  name: string;
  displayName: string;
  building: {
    name: string;
    description: string;
    maxHP: number;
  };
  personality: string[];
  specialAbility: {
    name: string;
    description: string;
    effect: string;
  };
  startingPopulation: number;
  aiStrategy: AIStrategy;
  color: string;
}

export enum AIStrategy {
  AGGRESSIVE = 'AGGRESSIVE',
  DEFENSIVE = 'DEFENSIVE',
  BALANCED = 'BALANCED',
  CHAOS = 'CHAOS',
  PROPAGANDA = 'PROPAGANDA'
}
```

---

## Phase 3: Constants & Card Definitions (Day 1)

### Create: `shared/constants/factions.ts`

```typescript
import { FactionConfig, FactionType, AIStrategy } from '../types/factions';

export const FACTION_CONFIGS: Record<FactionType, FactionConfig> = {
  [FactionType.MAFA]: {
    type: FactionType.MAFA,
    name: 'MAFA',
    displayName: 'Make America Fun Again',
    building: {
      name: 'The Golden Tower',
      description: 'Gaudy skyscraper with gold trim',
      maxHP: 100
    },
    personality: ['Aggressive', 'Bombastic', 'Predictable'],
    specialAbility: {
      name: 'Rally Call',
      description: 'Double propaganda effectiveness once per game',
      effect: 'DOUBLE_PROPAGANDA'
    },
    startingPopulation: 50,
    aiStrategy: AIStrategy.AGGRESSIVE,
    color: '#FF4444'
  },
  [FactionType.BLAM]: {
    type: FactionType.BLAM,
    name: 'BLAM',
    displayName: 'Big Loud Activist Movement',
    building: {
      name: 'The Community Center',
      description: 'Grassroots hub with murals',
      maxHP: 80
    },
    personality: ['Collective', 'Multi-target', 'Collaborative'],
    specialAbility: {
      name: 'Mass Mobilization',
      description: 'Launch two protests in one turn',
      effect: 'DOUBLE_PROTEST'
    },
    startingPopulation: 55,
    aiStrategy: AIStrategy.BALANCED,
    color: '#FF8800'
  },
  [FactionType.AUNTY_FAFA]: {
    type: FactionType.AUNTY_FAFA,
    name: 'Aunty Fafa',
    displayName: 'Aunty Fafa',
    building: {
      name: 'The Collective',
      description: 'Underground bunker/safehouse',
      maxHP: 120
    },
    personality: ['Chaotic', 'Unpredictable', 'High-risk'],
    specialAbility: {
      name: 'Black Bloc',
      description: 'Throwing attacks do +50% damage',
      effect: 'BOOST_THROWING'
    },
    startingPopulation: 45,
    aiStrategy: AIStrategy.CHAOS,
    color: '#000000'
  },
  [FactionType.PROUD_GALS]: {
    type: FactionType.PROUD_GALS,
    name: 'Proud Gals',
    displayName: 'Proud Gals',
    building: {
      name: 'The Clubhouse',
      description: 'Fortified lodge with perimeter',
      maxHP: 110
    },
    personality: ['Defensive', 'Patient', 'Strategic'],
    specialAbility: {
      name: 'Stand Back Stand By',
      description: 'Building takes 50% less damage',
      effect: 'REDUCE_BUILDING_DAMAGE'
    },
    startingPopulation: 48,
    aiStrategy: AIStrategy.DEFENSIVE,
    color: '#FFD700'
  },
  [FactionType.LMNOP]: {
    type: FactionType.LMNOP,
    name: 'LMNOP',
    displayName: 'Alphabet Gang',
    building: {
      name: 'Rainbow HQ',
      description: 'Colorful headquarters with flags',
      maxHP: 90
    },
    personality: ['Diplomatic', 'Persuasive', 'Strategic'],
    specialAbility: {
      name: 'Pride Parade',
      description: 'Propaganda steals +10 million extra',
      effect: 'BOOST_PROPAGANDA'
    },
    startingPopulation: 52,
    aiStrategy: AIStrategy.PROPAGANDA,
    color: '#9B59B6'
  }
};
```

### Create: `shared/constants/cards.ts`

```typescript
import { CardType, ActionType } from '../types/cards';

// Define all card templates
export const CARD_DEFINITIONS = {
  COVERT_OPS: [
    {
      id: 'scandal-leak',
      name: 'Scandal Leak',
      count: 3,
      effect: { type: 'DAMAGE_POPULATION', amount: 15 }
    },
    {
      id: 'infiltrator',
      name: 'Infiltrator',
      count: 2,
      effect: { type: 'STEAL_POPULATION', amount: 10 }
    },
    // ... more covert ops
  ],
  PROPAGANDA: [
    {
      id: 'social-media-blitz',
      name: 'Social Media Blitz',
      count: 4,
      stealAmount: 10
    },
    {
      id: 'meme-warfare',
      name: 'Meme Warfare',
      count: 3,
      stealAmount: 8
    },
    // ... more propaganda
  ],
  ORGANIZATIONS: [
    {
      id: 'protest-group',
      name: 'Protest Group',
      count: 6,
      actionType: ActionType.PROTEST
    },
    // ... more organizations
  ],
  ACTION_PLANS: [
    {
      id: 'peaceful-march',
      name: 'Peaceful March',
      count: 4,
      actionType: ActionType.PROTEST,
      damage: 10,
      targetType: 'POPULATION'
    },
    // ... more action plans
  ],
  DEFENSES: [
    {
      id: 'security-detail',
      name: 'Security Detail',
      count: 3,
      blocksType: ActionType.THROWING
    },
    // ... more defenses
  ]
};

export const POPULATION_CARD_VALUES = [
  { value: 1, count: 10 },
  { value: 5, count: 8 },
  { value: 10, count: 6 },
  { value: 15, count: 4 },
  { value: 25, count: 2 }
];
```

---

## Phase 4: Backend Core Game Engine (Days 2-3)

### Create: `server/src/utils/gameEngine.ts`

```typescript
import { GameState, GamePhase, Faction, FactionType } from '../../../shared/types/game';
import { GameCard, CardType } from '../../../shared/types/cards';
import { FACTION_CONFIGS } from '../../../shared/constants/factions';
import { createDeck, dealCards } from './cardDeck';

export class GameEngine {
  private state: GameState;

  constructor(playerCount: number = 5) {
    this.state = this.initializeGame(playerCount);
  }

  private initializeGame(playerCount: number): GameState {
    const factions: Faction[] = [];
    const factionTypes = Object.values(FactionType);

    // Create factions (1 human + 4 AI)
    for (let i = 0; i < playerCount; i++) {
      const factionType = factionTypes[i];
      const config = FACTION_CONFIGS[factionType];
      
      factions.push({
        id: `faction-${i}`,
        type: factionType,
        name: config.displayName,
        isAI: i > 0, // First player is human
        population: this.dealPopulationCards(config.startingPopulation),
        totalPopulation: config.startingPopulation,
        buildingHP: config.building.maxHP,
        maxBuildingHP: config.building.maxHP,
        hand: [],
        queue: [],
        organizations: [],
        specialAbilityUsed: false,
        isEliminated: false,
        capturedBuildings: []
      });
    }

    // Create and shuffle deck
    const deck = createDeck();

    // Deal initial cards to each faction
    factions.forEach(faction => {
      faction.hand = dealCards(deck, 9);
    });

    return {
      id: `game-${Date.now()}`,
      phase: GamePhase.SETUP,
      round: 0,
      currentPlayerIndex: 0,
      factions,
      deck,
      discardPile: [],
      eventLog: [],
      winner: null
    };
  }

  private dealPopulationCards(totalPopulation: number): PopulationCard[] {
    // Logic to deal population cards that sum to totalPopulation
    const cards: PopulationCard[] = [];
    let remaining = totalPopulation;
    const values = [25, 15, 10, 5, 1];

    for (const value of values) {
      while (remaining >= value) {
        cards.push({
          id: `pop-${Date.now()}-${Math.random()}`,
          value
        });
        remaining -= value;
      }
    }

    return cards;
  }

  public getState(): GameState {
    return this.state;
  }

  public playCard(factionId: string, cardId: string): GameState {
    // Implement card playing logic
    const faction = this.state.factions.find(f => f.id === factionId);
    if (!faction) throw new Error('Faction not found');

    // Add card to queue (face-down)
    const card = faction.hand.find(c => c.id === cardId);
    if (!card) throw new Error('Card not in hand');

    faction.queue.push(card);
    faction.hand = faction.hand.filter(c => c.id !== cardId);

    // Reveal oldest card if queue has 3 cards
    if (faction.queue.length === 3) {
      this.revealOldestCard(factionId);
    }

    return this.state;
  }

  private revealOldestCard(factionId: string): void {
    const faction = this.state.factions.find(f => f.id === factionId);
    if (!faction || faction.queue.length === 0) return;

    const card = faction.queue.shift()!; // Remove oldest (FIFO)
    this.resolveCard(faction, card);
  }

  private resolveCard(faction: Faction, card: GameCard): void {
    switch (card.type) {
      case CardType.COVERT_OP:
        this.resolveCovertOp(faction, card);
        break;
      case CardType.PROPAGANDA:
        if (this.state.phase === GamePhase.PEACETIME) {
          this.resolvePropaganda(faction, card);
        } else {
          // Discard during conflict
          this.state.discardPile.push(card);
        }
        break;
      case CardType.ORGANIZATION:
        this.placeOrganization(faction, card);
        break;
      case CardType.ACTION_PLAN:
        this.attachActionPlan(faction, card);
        break;
      case CardType.DEFENSE:
        // Keep in hand for reactive use
        faction.hand.push(card);
        break;
    }

    // Draw replacement card
    if (this.state.deck.length > 0) {
      faction.hand.push(this.state.deck.pop()!);
    }
  }

  // ... implement all resolution methods

  public executeAttack(attackerId: string, targetId: string, organizationId: string): GameState {
    // Implementation of attack logic
    const attacker = this.state.factions.find(f => f.id === attackerId);
    const target = this.state.factions.find(f => f.id === targetId);
    
    if (!attacker || !target) throw new Error('Invalid faction IDs');

    const org = attacker.organizations.find(o => o.id === organizationId);
    if (!org || !org.attachedAction) throw new Error('No action attached');

    // Trigger conflict mode if in peacetime
    if (this.state.phase === GamePhase.PEACETIME) {
      this.state.phase = GamePhase.CONFLICT;
      this.logEvent(`${attacker.name} launches attack! Conflict mode begins.`);
    }

    // Calculate damage
    const action = org.attachedAction;
    let damage = action.damage || 0;

    // Apply faction bonuses
    if (attacker.type === FactionType.AUNTY_FAFA && action.actionType === ActionType.THROWING) {
      damage *= 1.5; // Black Bloc ability
    }

    if (target.type === FactionType.PROUD_GALS && action.targetType === 'BUILDING') {
      damage *= 0.5; // Stand Back Stand By ability
    }

    // Apply damage
    if (action.targetType === 'POPULATION') {
      this.damagePopulation(target, damage);
    } else if (action.targetType === 'BUILDING') {
      this.damageBuilding(target, damage);
    }

    // Remove organization and action from play
    attacker.organizations = attacker.organizations.filter(o => o.id !== organizationId);

    // Check for elimination
    this.checkElimination(target);

    return this.state;
  }

  private damagePopulation(faction: Faction, amount: number): void {
    let remaining = amount;
    
    while (remaining > 0 && faction.population.length > 0) {
      const card = faction.population[faction.population.length - 1];
      if (card.value <= remaining) {
        remaining -= card.value;
        faction.population.pop();
      } else {
        // Split card
        card.value -= remaining;
        remaining = 0;
      }
    }

    faction.totalPopulation = faction.population.reduce((sum, c) => sum + c.value, 0);
    this.logEvent(`${faction.name} loses ${amount}M population!`);
  }

  private damageBuilding(faction: Faction, amount: number): void {
    faction.buildingHP = Math.max(0, faction.buildingHP - amount);
    this.logEvent(`${faction.name}'s building takes ${amount} damage!`);

    if (faction.buildingHP === 0) {
      this.logEvent(`${faction.name}'s building is destroyed!`);
      faction.specialAbilityUsed = true; // Lose ability
    }
  }

  private checkElimination(faction: Faction): void {
    if (faction.totalPopulation <= 0 && !faction.isEliminated) {
      faction.isEliminated = true;
      this.logEvent(`${faction.name} has been eliminated!`);
      this.triggerFinalRetaliation(faction);
      
      // Return to peacetime after final retaliation resolves
      this.state.phase = GamePhase.PEACETIME;
    }
  }

  private triggerFinalRetaliation(faction: Faction): void {
    this.logEvent(`${faction.name} launches final retaliation!`);
    this.state.phase = GamePhase.FINAL_RETALIATION;

    // Launch all remaining organizations with attached actions
    faction.organizations.forEach(org => {
      if (org.attachedAction) {
        // Pick random target
        const targets = this.state.factions.filter(f => !f.isEliminated && f.id !== faction.id);
        if (targets.length > 0) {
          const target = targets[Math.floor(Math.random() * targets.length)];
          // Execute attack without removing from organizations (already eliminated)
          // ... damage calculation logic here
        }
      }
    });

    // Play all covert ops
    // ... covert op logic here
  }

  private logEvent(message: string): void {
    this.state.eventLog.push({
      id: `event-${Date.now()}-${Math.random()}`,
      timestamp: Date.now(),
      type: 'INFO',
      message
    });
  }

  public checkWinCondition(): string | null {
    const activeFactions = this.state.factions.filter(f => !f.isEliminated);
    
    // Check last faction standing
    if (activeFactions.length === 1) {
      this.state.winner = activeFactions[0].id;
      this.state.phase = GamePhase.ENDED;
      return activeFactions[0].id;
    }

    // Check total annihilation
    if (activeFactions.length === 0) {
      this.state.phase = GamePhase.ENDED;
      return 'NONE'; // No winner
    }

    // Check building domination
    for (const faction of activeFactions) {
      const ownedBuildings = 1 + faction.capturedBuildings.length;
      if (ownedBuildings >= 3) {
        this.state.winner = faction.id;
        this.state.phase = GamePhase.ENDED;
        return faction.id;
      }
    }

    return null;
  }
}
```

---

## Phase 5: AI Engine (Day 3)

### Create: `server/src/utils/aiEngine.ts`

```typescript
import { Faction, GameState, FactionType } from '../../../shared/types/game';
import { GameCard, CardType, ActionType } from '../../../shared/types/cards';
import { AIStrategy } from '../../../shared/types/factions';
import { FACTION_CONFIGS } from '../../../shared/constants/factions';

export class AIEngine {
  public decideAction(faction: Faction, gameState: GameState): AIAction {
    const strategy = FACTION_CONFIGS[faction.type].aiStrategy;

    switch (strategy) {
      case AIStrategy.AGGRESSIVE:
        return this.aggressiveStrategy(faction, gameState);
      case AIStrategy.DEFENSIVE:
        return this.defensiveStrategy(faction, gameState);
      case AIStrategy.PROPAGANDA:
        return this.propagandaStrategy(faction, gameState);
      case AIStrategy.CHAOS:
        return this.chaosStrategy(faction, gameState);
      default:
        return this.balancedStrategy(faction, gameState);
    }
  }

  private aggressiveStrategy(faction: Faction, gameState: GameState): AIAction {
    // Target strongest opponent, prefer direct attacks
    const targets = gameState.factions.filter(f => !f.isEliminated && f.id !== faction.id);
    const strongest = targets.reduce((prev, curr) => 
      curr.totalPopulation > prev.totalPopulation ? curr : prev
    );

    // Prefer throwing attacks and riots
    const throwingCards = faction.hand.filter(c => 
      c.type === CardType.ACTION_PLAN && c.actionType === ActionType.THROWING
    );

    if (throwingCards.length > 0 && faction.organizations.length > 0) {
      return {
        type: 'ATTACH_ACTION',
        cardId: throwingCards[0].id,
        organizationId: faction.organizations[0].id,
        targetId: strongest.id
      };
    }

    // Play organizations if available
    const orgCards = faction.hand.filter(c => c.type === CardType.ORGANIZATION);
    if (orgCards.length > 0) {
      return {
        type: 'PLAY_CARD',
        cardId: orgCards[0].id
      };
    }

    // Default: play random card
    return {
      type: 'PLAY_CARD',
      cardId: faction.hand[Math.floor(Math.random() * faction.hand.length)].id
    };
  }

  private defensiveStrategy(faction: Faction, gameState: GameState): AIAction {
    // Build up defenses first, counter-attack when ready
    
    // Prioritize prayer actions for healing
    const prayerCards = faction.hand.filter(c => 
      c.type === CardType.ACTION_PLAN && c.actionType === ActionType.PRAYER
    );

    // Check if building is damaged
    if (faction.buildingHP < faction.maxBuildingHP && prayerCards.length > 0) {
      const prayerOrg = faction.organizations.find(o => o.actionType === ActionType.PRAYER);
      if (prayerOrg) {
        return {
          type: 'ATTACH_ACTION',
          cardId: prayerCards[0].id,
          organizationId: prayerOrg.id,
          targetId: faction.id // Heal self
        };
      }
    }

    // Build up organizations
    const orgCards = faction.hand.filter(c => c.type === CardType.ORGANIZATION);
    if (orgCards.length > 0 && faction.organizations.length < 3) {
      return {
        type: 'PLAY_CARD',
        cardId: orgCards[0].id
      };
    }

    // Attack weakest when ready
    const targets = gameState.factions.filter(f => !f.isEliminated && f.id !== faction.id);
    const weakest = targets.reduce((prev, curr) => 
      curr.totalPopulation < prev.totalPopulation ? curr : prev
    );

    // ... continue with attack logic

    return { type: 'PLAY_CARD', cardId: faction.hand[0].id };
  }

  private propagandaStrategy(faction: Faction, gameState: GameState): AIAction {
    // Heavy propaganda use in peacetime
    if (gameState.phase === 'PEACETIME') {
      const propagandaCards = faction.hand.filter(c => c.type === CardType.PROPAGANDA);
      if (propagandaCards.length > 0) {
        const targets = gameState.factions.filter(f => !f.isEliminated && f.id !== faction.id);
        const largestPop = targets.reduce((prev, curr) => 
          curr.totalPopulation > prev.totalPopulation ? curr : prev
        );

        return {
          type: 'PLAY_PROPAGANDA',
          cardId: propagandaCards[0].id,
          targetId: largestPop.id
        };
      }
    }

    // Avoid conflict until forced
    return { type: 'PLAY_CARD', cardId: faction.hand[0].id };
  }

  private chaosStrategy(faction: Faction, gameState: GameState): AIAction {
    // Completely random, high-risk plays
    const randomCard = faction.hand[Math.floor(Math.random() * faction.hand.length)];
    const randomTarget = gameState.factions.filter(f => !f.isEliminated && f.id !== faction.id)[0];

    return {
      type: 'PLAY_CARD',
      cardId: randomCard.id,
      targetId: randomTarget?.id
    };
  }

  private balancedStrategy(faction: Faction, gameState: GameState): AIAction {
    // Mix of all strategies
    // ... implement balanced logic
    return { type: 'PLAY_CARD', cardId: faction.hand[0].id };
  }
}

export interface AIAction {
  type: 'PLAY_CARD' | 'ATTACH_ACTION' | 'PLAY_PROPAGANDA' | 'USE_DEFENSE';
  cardId: string;
  organizationId?: string;
  targetId?: string;
}
```

---

## Phase 6: Frontend Game UI (Days 4-5)

### Create: `client/src/components/game/GameBoard.tsx`

```typescript
import React from 'react';
import { GameState } from '../../../../shared/types/game';
import FactionCard from './FactionCard';
import EventLog from './EventLog';

interface GameBoardProps {
  gameState: GameState;
  onAction: (action: any) => void;
}

export const GameBoard: React.FC<GameBoardProps> = ({ gameState, onAction }) => {
  return (
    <div className="game-board w-full h-screen bg-gray-900 p-4">
      {/* Faction displays arranged in pentagon */}
      <div className="factions-container relative h-3/4">
        {gameState.factions.map((faction, index) => (
          <FactionCard
            key={faction.id}
            faction={faction}
            position={index}
            isCurrentPlayer={index === gameState.currentPlayerIndex}
            onAction={onAction}
          />
        ))}
      </div>

      {/* Player's hand at bottom */}
      <div className="player-hand h-1/4 bg-gray-800 rounded-lg p-4">
        {/* Card hand component */}
      </div>

      {/* Event log */}
      <EventLog events={gameState.eventLog} />
    </div>
  );
};
```

### Create: `client/src/components/game/FactionCard.tsx`

```typescript
import React from 'react';
import { Faction } from '../../../../shared/types/game';
import { FACTION_CONFIGS } from '../../../../shared/constants/factions';

interface FactionCardProps {
  faction: Faction;
  position: number;
  isCurrentPlayer: boolean;
  onAction: (action: any) => void;
}

export const FactionCard: React.FC<FactionCardProps> = ({
  faction,
  position,
  isCurrentPlayer,
  onAction
}) => {
  const config = FACTION_CONFIGS[faction.type];
  
  // Calculate position in pentagon layout
  const angle = (position / 5) * 2 * Math.PI - Math.PI / 2;
  const radius = 40; // percentage
  const x = 50 + radius * Math.cos(angle);
  const y = 50 + radius * Math.sin(angle);

  return (
    <div
      className={`faction-card absolute transform -translate-x-1/2 -translate-y-1/2 
                  ${isCurrentPlayer ? 'ring-4 ring-yellow-400' : ''}
                  ${faction.isEliminated ? 'opacity-50 grayscale' : ''}`}
      style={{
        left: `${x}%`,
        top: `${y}%`,
        borderColor: config.color
      }}
    >
      {/* Faction name */}
      <h3 className="text-xl font-bold" style={{ color: config.color }}>
        {faction.name}
      </h3>

      {/* Building */}
      <div className="building mt-2">
        <div className="building-name text-sm">{config.building.name}</div>
        <div className="health-bar bg-gray-700 h-4 rounded">
          <div
            className="health-fill bg-green-500 h-full rounded"
            style={{ width: `${(faction.buildingHP / faction.maxBuildingHP) * 100}%` }}
          />
        </div>
        <div className="health-text text-xs">
          {faction.buildingHP} / {faction.maxBuildingHP} HP
        </div>
      </div>

      {/* Population */}
      <div className="population mt-2">
        <span className="text-2xl font-bold">{faction.totalPopulation}M</span>
        <span className="text-xs ml-1">population</span>
      </div>

      {/* Organizations in play */}
      <div className="organizations mt-2">
        {faction.organizations.map(org => (
          <div key={org.id} className="org-card text-xs bg-gray-700 p-1 rounded">
            {org.name}
            {org.attachedAction && (
              <span className="text-green-400 ml-1">⚡</span>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};
```

---

## Phase 7: Database & Leaderboard (Day 6)

### Create: `server/prisma/schema.prisma`

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  username  String   @unique
  email     String?  @unique
  createdAt DateTime @default(now())
  matches   Match[]
  stats     UserStats?
}

model UserStats {
  id                Int      @id @default(autoincrement())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id])
  totalWins         Int      @default(0)
  totalGames        Int      @default(0)
  totalEliminations Int      @default(0)
  buildingsCaptured Int      @default(0)
  propagandaVictories Int    @default(0)
  longestWinStreak  Int      @default(0)
  currentStreak     Int      @default(0)
  rating            Int      @default(1000)
  favoriteFaction   String?
}

model Match {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  factionType String
  result      String   // WIN, LOSS, DRAW
  score       Int
  eliminations Int
  duration    Int      // seconds
  createdAt   DateTime @default(now())
}
```

### Run migrations:
```bash
cd server
npx prisma migrate dev --name init
npx prisma generate
```

---

## Phase 8: Socket.io Real-time (Day 6)

### Create: `server/src/config/socket.ts`

```typescript
import { Server as HTTPServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import { GameEngine } from '../utils/gameEngine';

export function setupSocket(httpServer: HTTPServer) {
  const io = new SocketServer(httpServer, {
    cors: {
      origin: process.env.CLIENT_URL || 'http://localhost:5173',
      methods: ['GET', 'POST']
    }
  });

  const games = new Map<string, GameEngine>();

  io.on('connection', (socket) => {
    console.log('Client connected:', socket.id);

    socket.on('create_game', () => {
      const game = new GameEngine(5);
      const gameId = game.getState().id;
      games.set(gameId, game);
      socket.join(gameId);
      socket.emit('game_created', { gameId, state: game.getState() });
    });

    socket.on('play_card', ({ gameId, factionId, cardId }) => {
      const game = games.get(gameId);
      if (!game) return;

      const newState = game.playCard(factionId, cardId);
      io.to(gameId).emit('game_updated', newState);
    });

    socket.on('execute_attack', ({ gameId, attackerId, targetId, organizationId }) => {
      const game = games.get(gameId);
      if (!game) return;

      const newState = game.executeAttack(attackerId, targetId, organizationId);
      io.to(gameId).emit('game_updated', newState);

      // Check win condition
      const winner = game.checkWinCondition();
      if (winner) {
        io.to(gameId).emit('game_ended', { winner, finalState: newState });
      }
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);
    });
  });

  return io;
}
```

---

## Phase 9: Deployment (Day 7)

### Frontend (Vercel)

1. Create `vercel.json` in client/:
```json
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "framework": "vite"
}
```

2. Deploy:
```bash
cd client
vercel --prod
```

### Backend (Railway)

1. Create `Procfile` in server/:
```
web: npm start
```

2. Create `railway.json`:
```json
{
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "npm start",
    "restartPolicyType": "ON_FAILURE"
  }
}
```

3. Deploy:
```bash
cd server
railway up
```

---

## Testing Strategy

### Unit Tests
```bash
# Client
cd client
npm install -D vitest @testing-library/react
npm run test

# Server
cd server
npm install -D jest @types/jest ts-jest
npm run test
```

### Integration Tests
- Test game engine logic
- Test AI decision making
- Test socket connections
- Test database operations

---

## Key Implementation Notes

1. **Start with single-player** - Get AI working first before multiplayer
2. **Test game logic thoroughly** - Card effects, damage calculation, win conditions
3. **Keep UI simple initially** - Focus on functionality over polish
4. **Use placeholder graphics** - Can improve art later
5. **Log everything** - Event log is crucial for debugging
6. **Handle edge cases** - Empty deck, simultaneous eliminations, etc.

---

## Contest Submission Checklist

- [ ] Game is playable end-to-end
- [ ] All 5 factions work with unique abilities
- [ ] AI opponents function properly
- [ ] Leaderboard tracks scores
- [ ] Deployed and accessible via URL
- [ ] Screenshots/demo video recorded
- [ ] README with instructions
- [ ] Code is clean and documented
- [ ] Git repository is public
- [ ] Twitter post with demo link

---

## Optimization Tips

1. **Performance:**
   - Memoize React components
   - Debounce socket events
   - Use indexes on database queries

2. **User Experience:**
   - Add animations for card plays
   - Sound effects for attacks
   - Victory animations
   - Tutorial mode

3. **Code Quality:**
   - TypeScript strict mode
   - ESLint + Prettier
   - Consistent naming
   - Comments on complex logic

---

## Next Steps After Contest

- Add more factions
- Tournament mode
- Replay system
- Custom game rules
- Mobile responsive design
- Progressive Web App
- Achievements system
- Friend system

---

**END OF DEVELOPMENT GUIDE**

Good luck building Political War!
